---
layout: documentation
title: Core concepts
---

At it's core, Dataform runs SQL queries against your warehouse, in the correct order. It also provides a framework to make it easy to develop queries and dependencies, provides templating so you can re-use code across different queries, and provides pre built packages that you can use within your project so you don't have to re-invent the wheel.

There are 3 main types of things you can do in dataform:

[Materialize data sets](/guides/materializations) - create a table, or view in your warehouse from a SQL query.

[Execute arbitrary queries](/guides/operations) - run arbitrary SQL queries against your warehouse.

[Run assertions against your data](/guides/assertions) - check that data conforms to certain rules.

## Directed graph

Dataform compiles your project and computes a directed, acyclic graph of all the queries that should be run, and makes sure to run them in the correct order.

## API

Dataform provides APIs to make it easy to perform common tasks, such as [creating a table]((/guides/materializations), or incrementally inserting new rows into a table.

## JS API

Dataform provides a way to define anything in dataform via JavaScript, check out the [JS API reference](/reference/js-api) for more info.

## Compiling, building, running

For any dataform project to be run, there are 3 main steps that happen in the following order:

### 1. Compile

The compilation step turns a project's contents and files into a JSON object called a `compiled-graph`. This contains structured information about all nodes (materializations, operations, assertions) in the project.

### 2. Build

The `compiled-graph` is turned into an `executable-graph` during the build step.
An `executable-graph` is generated by combining the compiled graph with information from the data warehouse (the `warehouse-state`) about the current state of tables and views, and as a result needs a profile to be created.

The output of this step is a complete set of SQL queries that will be executed, and preserves information about dependencies within the project.

### 3. Run

Finally, an `executable-graph` can be run against the warehouse, where the SQL statements will actually be executed in the correct order. The output of this step is an `executed-graph`, which contains the SQL statements that were executed and their status, or any error messages.
